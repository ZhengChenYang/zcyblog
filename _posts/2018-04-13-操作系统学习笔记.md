---
layout: post
title:  "操作系统学习笔记"
date:   2018-04-13 10:20:00 +0800
categories: 操作系统
---

# 用户态和内核态 #
## 使用内核态的原因 ##
限制不同程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发到网络，CPU划分出连个权限等级：**用户态**和**内核态**

## 用户态切换内核态流程 ##
1. 用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务.
2. 用户态程序执行陷阱指令
3. CPU切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问
4. 这些指令称之为陷阱(trap)或者系统调用处理器(system call handler). 他们会读取程序放入内存的数据参数, 并执行程序请求的服务
5. 系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果

## IO操作 ##
### 操作流程 ###
1. 应用程序发起IO调用（如fwrite/fread），要写入的数据被复制到应用层缓冲区中，在应用层缓冲区中数据会被重新组合，使得传递给下一步的数据是对齐的。（这一步的操作时非必需的，当调用库函数fwrite/fread时，会有这一层的缓冲，但如果是直接调用的系统函数write/read，将直接跳到下一步）
2. 系统由用户态切换到系统态，数据被写入到系统缓冲区，这一步完成后write函数就认为写操作已经完成了，返回写数据结果（选择同步IO除外，选择同步IO的话会等到step4完成后才会返回）。
3. 系统缓冲区内的数据被复制到操作系统page里面进行进一步的组合
4. 数据被写入到硬盘的cache中，等待合适的时机将数据写到硬盘的指定位置；
5. 硬盘的磁头到达指定的位置，将数据写入到硬盘中；只有当这一步完成时，数据才是真正的被保存下去了，如果在这一步完成之前出现异常，数据将会丢失。  

### 阻塞与非阻塞 同步与异步 ###
实际上，我们可以把IO请求分为两个阶段。
1. 等待资源阶段，资源未到达内核。可能还在别的线程手中，可能还在等待磁盘读写，等待网卡接受或者发送。这个时候，因为IO时间较长，**应用线程挂起**，IO请求会被阻塞，直到能够接收到资源。
2. 使用资源阶段，资源已到达内核，程序可以使用，数据从内核空间复制到用户空间阶段。

IO可以分为阻塞IO和非阻塞IO。
1. **阻塞IO**：资源不可用的时候，IO**请求阻塞**，**线程挂起**
2. **非阻塞IO**：资源不可用时，IO请求**立刻返回**，返回数据标识资源不可用，**线程不挂起**。  

IO可以分为同步IO和异步IO
1. **同步IO**：遇到IO操作时，线程可能挂起也可能不停的轮询。关键是，**必等IO操作完成**，才进入下一阶段执行。
2. **异步IO**：应用发送或接受数据后立刻返回，有内核负责接受数据返回成功或者失败给应用。线程**不等IO操作完成**，直接进入下一阶段。
在linux中，阻塞式I/O、非阻塞式I/O、I/O复用和信号驱动I/O都是同步I/O,他们在第一阶段有所区别。但在第二阶段，资源使用阶段（数据从内核空间复制到用户空间阶段）任然需要该线程亲自完成。以此完成整个IO操作，接着才继续别的事情。

这里衍生一下，如果阻塞和非阻塞的区别可以看线程是否挂起。那么同步与异步应该算一种思想。如果有A,B两件事情，且A做完之后做B.  
**同步**:在A事情没做完前不做别的C事情，直到A做完->B做完->做C，同步是有**顺序**的  
**异步**:告诉别人去做A，做完A后做B,自己则不管直接去做C。别人做完A后做B，通知下。
这种思想的本质是是否把任务扔给别人完成，自己不管。从消息通知机制角度来看，也可以区分，同步是主动获取信息（通过阻塞或者轮询），异步是让别人来通知自己。
这种思想其实也不仅仅体现在操作系统的IO上，还有编程模型上。



### 分析Java中的NIO ###
Java中的NIO被称为同步非阻塞IO。实际上，NIO底层使用的是IO多路复用——epoll。而epoll实际上是一个阻塞IO，那为什么我们称NIO为同步非阻塞IO呢？
1. NIO是同步的
在使用资源阶段，由应用去内核读取数据到用户空间，没有数据则继续轮询直到文件描述符发生改变。**对应用来说，使用阶段没有把任务扔给别人，亲力亲为**（轮询）完整的完成了IO的两个阶段。所以是同步的。
2. NIO是非阻塞的
epoll是阻塞的。但这里的非阻塞还是看编程模型，不是指底层的IO是否阻塞。NIO把**等待资源阶段**交给了epoll来管理，而应用程序只需要负责**使用资源阶段**。调用read时候要么读到n字节,要么读到字节不够n个立刻返回。从应用线程角度看，线程不会挂起阻塞。 （如果设置阻塞模式的话，读不到指定字节数会发生阻塞，直到读完）


# 进程通信 #
1. 管道（pipe）:管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2. 命名管道（FIFO）：半双工的通信方式，但是它允许无亲缘关系进程间的通信。
3. 消息队列（MessageQueue）:消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. 共享存储（SharedMemory）：映射一段能被其他进程访问的内存，效率最高。配合信号量使用。
5. 信号量（semaphore）:信号量是一个计数器信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
6. 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
7. 信号 (sinal) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

# 线程同步 #
1. 事件(Event)
2. 信号量(semaphore)  
信号量是维护0到指定最大值之间的同步对象。信号量状态在其计数大于0时是有信号的，而其计数是0时是无信号的。信号量对象在控制上可以支持有限数量共享资源的访问。
3. 互斥量(mutex)  
mutex本质上说就是一把锁，提供对资源的独占访问，所以Mutex主要的作用是用于互斥。Mutex对象的值，只有0和1两个值。这两个值也分别代表了Mutex的两种状态。值为0, 表示锁定状态，当前对象被锁定，用户进程/线程如果试图Lock临界资源，则进入排队等待；值为1，表示空闲状态，当前对象为空闲，用户进程/线程可以Lock临界资源，之后Mutex值减1变为0。
4. 临界区(Critical section)  
临界区（Critical Section）是一段独占对某些共享资源访问的代码，在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。

# 内存管理 #
## 分段和分页 ##
内存管理可以分成两种：
1. 段式内存管理  
段式内存管理，就是将内存分成段，每个段的起始地址就是段基地址。地址映射的时候，由逻辑地址加上段基地址而得到物理地址。纯粹的段式内存管理的缺点很明显，就是灵活性和效率比较差。首先是段的长度是可变的，这给内存的换入换出带来诸多不便，如何选择一个段的长度是一个棘手的问题；其次进程在运行过程中，可能会扩充地址空间，这就要增加段，从而造成进程的地址空间由很多小段构成，在进程运行过程中，访问不同的段时，就需要频繁切换段基地址；再一点，段式内存管理如果有太多的小段，在释放段的时候，会造成外部碎片。 
2. 页式内存管理  
页式内存管理，内存分成固定长度的一个个页片。地址映射的时候，需要先建立页表，页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。

linux采用段页式内存管理，既分段又分页。这是为了支持一些不同的硬件体系架构。所以段大小相同。